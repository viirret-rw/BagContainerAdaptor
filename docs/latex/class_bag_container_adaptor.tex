\hypertarget{class_bag_container_adaptor}{}\doxysection{Bag\+Container\+Adaptor$<$ Type, Container $>$ Class Template Reference}
\label{class_bag_container_adaptor}\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}


{\ttfamily \#include $<$bag\+\_\+container\+\_\+adaptor.\+hpp$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}\label{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}} 
using \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} = typename Container\+::value\+\_\+type
\begin{DoxyCompactList}\small\item\em The value type of the underlying container. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}\label{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}} 
using \mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} = typename Container\+::iterator
\begin{DoxyCompactList}\small\item\em The iterator of the underlying container. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}\label{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}} 
using \mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} = typename Container\+::const\+\_\+iterator
\begin{DoxyCompactList}\small\item\em The constant iterator of the underlying container. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_bag_container_adaptor_a0d6616809e7ffd66f4b74538fdb17ae3}{Bag\+Container\+Adaptor}} () noexcept=default
\item 
\mbox{\hyperlink{class_bag_container_adaptor_a13888e5071deea22832a4d5749ef73f2}{Bag\+Container\+Adaptor}} (Container \&\&container) noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} \& \mbox{\hyperlink{class_bag_container_adaptor_a0c8666fb6bbfcf9010419e1f5332d37e}{operator=}} (\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} \&\&other) noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_ac6a2a1425e4c5261b2e8639ec55d8a3f}{Bag\+Container\+Adaptor}} (const \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} \&other) noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} \& \mbox{\hyperlink{class_bag_container_adaptor_a70adbb42ef84524beecddeb9b0731d8b}{operator=}} (const \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} \&other) noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor_ace485f3913c95fca47441e148279a7ad}{insert}} (const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&value)
\item 
void \mbox{\hyperlink{class_bag_container_adaptor_afaa77eaf2a6d1f5b401162116033ad75}{erase}} (\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} elem)
\item 
void \mbox{\hyperlink{class_bag_container_adaptor_a52c29ae7c2aa3e78ae7f0684f923e7d0}{erase}} (const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&value)
\item 
void \mbox{\hyperlink{class_bag_container_adaptor_a01e0ba62c25cac875c927a92f2c53820}{swap}} (\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} \&other) noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor_a53a7da26316c02ed6711487dbf686b24}{begin}} () noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor_a2465ce68ddb1a4c0dfff31b7470f8429}{end}} () noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} \mbox{\hyperlink{class_bag_container_adaptor_aa174ae23b5c4a859f62732a6bb3a50f7}{cbegin}} () const noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} \mbox{\hyperlink{class_bag_container_adaptor_a13a7cf8217b5cb417ba1918d57794ac3}{cend}} () const noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor_ac68467f3439fac96de1a981fdce91be4}{find}} (const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&value) noexcept
\item 
\mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} \mbox{\hyperlink{class_bag_container_adaptor_aeb4605b2b455b2d5b7910a1c19fcfe3f}{find}} (const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&value) const noexcept
\item 
const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \& \mbox{\hyperlink{class_bag_container_adaptor_a92e924e8e2591d83a4b60dc52ee70106}{front}} () const noexcept
\item 
const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \& \mbox{\hyperlink{class_bag_container_adaptor_aa7ce54a2190aa7802b72a6f492921721}{back}} () const noexcept
\item 
std\+::size\+\_\+t \mbox{\hyperlink{class_bag_container_adaptor_a1510540a7df22c9946d17b22f8ed1a14}{size}} () const noexcept
\item 
bool \mbox{\hyperlink{class_bag_container_adaptor_a934a74e918ec494e2f85634350637c3f}{empty}} () const noexcept
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Type, typename Container = std\+::vector$<$\+Type$>$$>$\newline
class Bag\+Container\+Adaptor$<$ Type, Container $>$}

Bag is an abstract data type that can store a collection of elements without regard to their order. Equal elements can appear multiple times in a bag. Although the elements container in a bag have no inherit order, iterating over the bag elements is guaranteed to visit each element exactly once. This bag takes in a type and an STL-\/compatible container as a template arguments and provides the same functionality for each container type following the design pattern of an adapter. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Type} & the type of the items in the underlying type. \\
\hline
{\em Container} & The underlying container type. \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_bag_container_adaptor_a0d6616809e7ffd66f4b74538fdb17ae3}\label{class_bag_container_adaptor_a0d6616809e7ffd66f4b74538fdb17ae3}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!BagContainerAdaptor@{BagContainerAdaptor}}
\index{BagContainerAdaptor@{BagContainerAdaptor}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{BagContainerAdaptor()}{BagContainerAdaptor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Default constructor. 
\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a13888e5071deea22832a4d5749ef73f2}\label{class_bag_container_adaptor_a13888e5071deea22832a4d5749ef73f2}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!BagContainerAdaptor@{BagContainerAdaptor}}
\index{BagContainerAdaptor@{BagContainerAdaptor}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{BagContainerAdaptor()}{BagContainerAdaptor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} (\begin{DoxyParamCaption}\item[{Container \&\&}]{container }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Move constructor. 
\begin{DoxyParams}{Parameters}
{\em container} & The underlying container from which the {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} is constructed. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The underlying container must have a move constructor to support moving its contents. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The {\ttfamily Bag\+Container\+Adapter} is constructed, taking ownership of the contents of the underlying container. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_ac6a2a1425e4c5261b2e8639ec55d8a3f}\label{class_bag_container_adaptor_ac6a2a1425e4c5261b2e8639ec55d8a3f}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!BagContainerAdaptor@{BagContainerAdaptor}}
\index{BagContainerAdaptor@{BagContainerAdaptor}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{BagContainerAdaptor()}{BagContainerAdaptor()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Copy constructor. 
\begin{DoxyParams}{Parameters}
{\em other} & The other \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} where we copy from. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Assumes the {\ttfamily other} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} is a valid instance 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
Creates a new \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} instance that is a copy of {\ttfamily other}. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_bag_container_adaptor_aa7ce54a2190aa7802b72a6f492921721}\label{class_bag_container_adaptor_aa7ce54a2190aa7802b72a6f492921721}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!back@{back}}
\index{back@{back}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}}\& \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get reference to the implied last element in the underlying container. \begin{DoxyReturn}{Returns}
Reference to the implied last element in the underlying container. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The container must not be empty. 
\end{DoxyPrecond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Time complexity\+:}

\begin{DoxyItemize}
\item 0(1) For containers that support the .\mbox{\hyperlink{class_bag_container_adaptor_aa7ce54a2190aa7802b72a6f492921721}{back()}} member function, and std\+::multiset.
\item 0(n) For std\+::forward\+\_\+list and std\+::unordered\+\_\+multiset. 
\end{DoxyItemize}
\end{DoxyParagraph}
\mbox{\Hypertarget{class_bag_container_adaptor_a53a7da26316c02ed6711487dbf686b24}\label{class_bag_container_adaptor_a53a7da26316c02ed6711487dbf686b24}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!begin@{begin}}
\index{begin@{begin}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get iterator pointing to the first element in the underlying container. \char`\"{}\+First\char`\"{} in reference to the implied iteration order withing the container. \begin{DoxyReturn}{Returns}
An iterator pointing to the first element in the underlying container. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_aa174ae23b5c4a859f62732a6bb3a50f7}\label{class_bag_container_adaptor_aa174ae23b5c4a859f62732a6bb3a50f7}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!cbegin@{cbegin}}
\index{cbegin@{cbegin}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{cbegin()}{cbegin()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::cbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get a constant iterator pointing to the first element in the underlying container. \char`\"{}\+First\char`\"{} in reference to the implied iteration order withing the container. \begin{DoxyReturn}{Returns}
A constant iterator pointing to the first element in the underlying container. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a13a7cf8217b5cb417ba1918d57794ac3}\label{class_bag_container_adaptor_a13a7cf8217b5cb417ba1918d57794ac3}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!cend@{cend}}
\index{cend@{cend}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{cend()}{cend()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::cend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get a constant iterator pointing one past the last element in the underlying container. \char`\"{}\+Last\char`\"{} in reference to the implied iteration order withing the container. \begin{DoxyReturn}{Returns}
A contant iterator pointing one past the last element in the underlying container. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a934a74e918ec494e2f85634350637c3f}\label{class_bag_container_adaptor_a934a74e918ec494e2f85634350637c3f}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!empty@{empty}}
\index{empty@{empty}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
bool \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get boolean describing if the underlying container is empty or not. \begin{DoxyReturn}{Returns}
Boolean describing if the underlying container is empty or not. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a2465ce68ddb1a4c0dfff31b7470f8429}\label{class_bag_container_adaptor_a2465ce68ddb1a4c0dfff31b7470f8429}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!end@{end}}
\index{end@{end}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{end()}{end()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get iterator pointing to the one past the last element in the underlying container. \char`\"{}\+Last\char`\"{} in reference to the implied iteration order withing the container. \begin{DoxyReturn}{Returns}
An iterator pointing one past the last element in the underlying container. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a52c29ae7c2aa3e78ae7f0684f923e7d0}\label{class_bag_container_adaptor_a52c29ae7c2aa3e78ae7f0684f923e7d0}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!erase@{erase}}
\index{erase@{erase}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
void \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::erase (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Erase all elements that have the specified value in the underlying container. 
\begin{DoxyParams}{Parameters}
{\em value} & The value of the elements that are removed. \\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{Postcondition}
All elements equal to the specified value in the underlying container are removed, and the \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} object is modified accordingly. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em Any} & exception that may be thrown by the underlying container\textquotesingle{}s {\ttfamily erase} function. This typically includes exceptions like those related to invalid iterators or invalid operations on the container. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_afaa77eaf2a6d1f5b401162116033ad75}\label{class_bag_container_adaptor_afaa77eaf2a6d1f5b401162116033ad75}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!erase@{erase}}
\index{erase@{erase}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
void \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}}}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Removes a specified element from the underlying container. 
\begin{DoxyParams}{Parameters}
{\em elem} & An iterator pointing to the element to be removed from the underlying container. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The {\ttfamily elem} iterator must be a valid iterator that points to a position within the underlying container. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The element at the specified {\ttfamily elem} in the underlying container is removed, and the {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} object is modified accordingly. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em Depending} & on the underlying container\textquotesingle{}s erase operation, this function might throw exceptions like\+:
\begin{DoxyItemize}
\item For std\+::vector\+: std\+::out\+\_\+of\+\_\+range if the {\ttfamily elem} iterator is invalid. 
\end{DoxyItemize}\\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Time complexity\+:}

\begin{DoxyItemize}
\item O(1) For containers with constant-\/time erase operation (e.\+g., std\+::vector, std\+::unordered\+\_\+set, std\+::unordered\+\_\+map).
\item O(n) For containers with linear-\/time erase operation (e.\+g., std\+::list, std\+::forward\+\_\+list) where n is the number of elements. 
\end{DoxyItemize}
\end{DoxyParagraph}
\mbox{\Hypertarget{class_bag_container_adaptor_aeb4605b2b455b2d5b7910a1c19fcfe3f}\label{class_bag_container_adaptor_aeb4605b2b455b2d5b7910a1c19fcfe3f}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!find@{find}}
\index{find@{find}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_a4a7b3b6c10f021b1021e343830d61bc0}{const\+\_\+iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::find (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get constant iterator pointing to instance of element with specified value in const context. 
\begin{DoxyParams}{Parameters}
{\em value} & The value to compare elements to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator pointing to the instance of element with specified value. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_ac68467f3439fac96de1a981fdce91be4}\label{class_bag_container_adaptor_ac68467f3439fac96de1a981fdce91be4}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!find@{find}}
\index{find@{find}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::find (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get iterator pointing to instance of element with specified value. 
\begin{DoxyParams}{Parameters}
{\em value} & The value to compare elements to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator pointing to the instance of element with specified value. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a92e924e8e2591d83a4b60dc52ee70106}\label{class_bag_container_adaptor_a92e924e8e2591d83a4b60dc52ee70106}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!front@{front}}
\index{front@{front}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{front()}{front()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}}\& \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get reference to the implied first element in the underlying container in const context. \begin{DoxyReturn}{Returns}
Reference to the implied first element in the underlying container. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The container must not be empty. 
\end{DoxyPrecond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_ace485f3913c95fca47441e148279a7ad}\label{class_bag_container_adaptor_ace485f3913c95fca47441e148279a7ad}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!insert@{insert}}
\index{insert@{insert}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor_ac5a50af33c5d0540cfbd05ea531b677b}{iterator}} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::insert (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_bag_container_adaptor_ada48418fde55d629869746bf6393ed29}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Insert element to the underlying container. 
\begin{DoxyParams}{Parameters}
{\em value} & The value to be inserted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the inserted element. 
\end{DoxyReturn}
\begin{DoxyPostcond}{Postcondition}
The {\ttfamily value} is inserted to the underlying container, and the {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} object is modified accordingly. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em Depending} & on the underlying container\textquotesingle{}s insertion operations, this function might throw exceptions like {\ttfamily std\+::bad\+\_\+alloc} if memory allocation fails. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a0c8666fb6bbfcf9010419e1f5332d37e}\label{class_bag_container_adaptor_a0c8666fb6bbfcf9010419e1f5332d37e}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!operator=@{operator=}}
\index{operator=@{operator=}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}\& \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Move assignment operator. 
\begin{DoxyParams}{Parameters}
{\em other} & The underlying container from which the {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} is created. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to the current {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} object after the move assignment. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The {\ttfamily Container} type must have a move assignment operator to support moving its contents. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The current {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} object takes ownership of the contents of the other {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}}. The other {\ttfamily \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}} is left in a valid but unspecified state. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a70adbb42ef84524beecddeb9b0731d8b}\label{class_bag_container_adaptor_a70adbb42ef84524beecddeb9b0731d8b}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!operator=@{operator=}}
\index{operator=@{operator=}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}\& \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Copy assignment operator. 
\begin{DoxyParams}{Parameters}
{\em other} & The other \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} where we copy from. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Assumes that both {\ttfamily this} and {\ttfamily other} Bag\+Container\+Adaptors are valid instances. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
Copies the content of {\ttfamily other} into {\ttfamily this} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_bag_container_adaptor_a1510540a7df22c9946d17b22f8ed1a14}\label{class_bag_container_adaptor_a1510540a7df22c9946d17b22f8ed1a14}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!size@{size}}
\index{size@{size}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
std\+::size\+\_\+t \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get the amount of elements in the underlying container. \begin{DoxyReturn}{Returns}
The amount of elements in the underlying container. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\begin{DoxyParagraph}{Time complexity\+:}

\begin{DoxyItemize}
\item O(1) For containers with constant-\/time size retrieval, such as std\+::unordered\+\_\+multiset and std\+::queue. These containers maintain an internal count of elements, allowing direct and constant-\/time access to the size.
\item O(n) For containers with linear-\/time size retrieval, such as std\+::vector, std\+::deque, std\+::list and std\+::multiset. These containers do not maintain an internal count of elements, requiring iteration through the elements to determine the size, resulting in linear time complexity. 
\end{DoxyItemize}
\end{DoxyParagraph}
\mbox{\Hypertarget{class_bag_container_adaptor_a01e0ba62c25cac875c927a92f2c53820}\label{class_bag_container_adaptor_a01e0ba62c25cac875c927a92f2c53820}} 
\index{BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}!swap@{swap}}
\index{swap@{swap}!BagContainerAdaptor$<$ Type, Container $>$@{BagContainerAdaptor$<$ Type, Container $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$typename Type , typename Container  = std\+::vector$<$\+Type$>$$>$ \\
void \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}$<$ Type, Container $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Swap the contents of two Bag\+Container\+Adaptors. 
\begin{DoxyParams}{Parameters}
{\em other} & The other bag to be swapped with. \\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{Postcondition}
The contents of this \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}} are swapped with the contents of the {\ttfamily other} \mbox{\hyperlink{class_bag_container_adaptor}{Bag\+Container\+Adaptor}}. 
\end{DoxyPostcond}

\begin{DoxyExceptions}{Exceptions}
{\em noexcept} & No exceptions are thrown by this operation. \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
The swap operation is performed using the underlying container\textquotesingle{}s swap operation, which is noexcept for most standard containers (like std\+::vector, std\+::deque, std\+::list, std\+::forward\+\_\+list, std\+::multiset, and std\+::unordered\+\_\+multiset), ensuring a fast and exception-\/safe swap. 
\end{DoxyNote}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Bag\+Container\+Adaptor/include/\+Bag\+Container\+Adaptor/bag\+\_\+container\+\_\+adaptor.\+hpp\end{DoxyCompactItemize}
